Задача 0.1. Бинарный поиск    
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 3 с
        Ограничение по памяти: 256 МБ

Реализуйте бинарный поиск на массиве чисел, отсортированном в неубывающем порядке. 
Запрещается использование готовых функций бинарного поиска из стандартных библиотек. 

Формат входных данных
В первой строке записано целое число n — количество чисел в массиве (0 ≤ n ≤ 3 * 10^5).
Во второй строке через пробел записаны n чисел массива. Все числа целые и принадлежат промежутку от -2^31 до 2^31 - 1 включительно. Числа в
массиве упорядочены по неубыванию.
В третьей строке записано целое число k — количество запросов (0 ≤ k ≤ 3 * 10^5).
В четвёртой строке через пробел записаны k целых чисел-запросов из промежутка от -2^31 до 2^31 - 1 включительно.

Формат выходных данных
Для каждого числа-запроса x в отдельной строке выведите через пробел числа b, l и r, где b равно 1, если x присутствует в массиве, или 0 в 
противном случае; l — индекс первого элемента, большего либо равного x; r — индекс первого элемента, большего x. Элементы массива нумеруются 
индексами от 0 до n-1.Если подходящих элементов в массиве нет, договоримся, что возвращаемый индекс будет равен n.

Пример
стандартный ввод  |  стандартный вывод	
_______________________________________
4		  |0 0 0
1 2 2 3		  |1 0 1
5		  |1 1 3
0 1 2 3 4	  |1 3 4
		  |0 4 4

Решение к задаче: Bin_search.cpp.

===============================================================================================================================================

Задача 0.1. Путь лягушки 
	Имя входного файла: стандартный ввод 
	Имя выходного файла: стандартный вывод 
	Ограничение по времени: 1 с 
	Ограничение по памяти: 256 МБ

В одном очень длинном и узком пруду по кувшинкам прыгает лягушка. Кувшинки в пруду расположены в один ряд. Лягушка начинает прыгать с первой 
кувшинки ряда и хочет закончить на последней. Но в силу вредности характера лягушка согласна прыгать только вперед через одну или через две 
кувшинки. Например, с кувшинки номер 1 она может прыгнуть лишь на кувшинки номер 3 и номер 4. 
На некоторых кувшинках сидят комарики. А именно, на i-ой кувшинке сидят a_i комаров. Когда лягушка приземляется на кувшинку, она съедает всех 
комариков, сидящих на ней. Лягушка хочет спланировать свой маршрут так, чтобы съесть как можно больше комаров. Помогите ей: скажите, какие 
кувшинки она должна посетить на своем пути.

Формат входных данных 
Первая строка входа содержит n — число кувшинок в пруду (1 ≤ n ≤ 100 000). Вторая строка содержит n чисел, разделенных одиночными пробелами. 
i-ое число сообщает, сколько комаров сидит на i-ой кувшинке (1 ≤ i ≤ n). Все числа целые, неотрицательные и не превосходят 1000.

Формат выходных данных 
В первой строке выведите одно число — максимальное число комаров, которые может съесть лягушка. Во второй строке выведите последовательность 
чисел — номера тех кувшинок, на которых должна побывать лягушка, в возрастающем порядке. Если решений несколько, выведите любое. Если лягушка 
не может добраться до последней кувшинки, то выведите одно число -1.

Пример 
стандартный ввод  |  стандартный вывод 
_______________________________________
6 		  |5
1 100 3 4 1000 0  |1 4 6
---------------------------------------
2		  |-1
8 9		  |

Решение к задаче: FrogWay.cpp.

===============================================================================================================================================

Задача 0.2. Единицы (часть 1)
	Имя входного файла: стандартный ввод
	Имя выходного файла: стандартный вывод
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

Дано число N. Необходимо определить, сколько есть бинарных строк длины N, в которых ровно K единиц.

Формат входных данных
Первая строка входных данных содержит два целых неотрицательных числа N и K (0 ≤ K ≤ N ≤ 1000).

Формат выходных данных
Выведите одно число — ответ на задачу. Так как ответ может быть очень большим, необходимо его вывести по модулю 10^9 + 7.

Примеры
стандартный ввод  |  стандартный вывод
_______________________________________
3 2               |3
---------------------------------------
4 0		  |1
---------------------------------------
5 4		  |5
---------------------------------------
6 4  		  |15
---------------------------------------
7 2		  |21
---------------------------------------
8 0		  |1

Решение к задаче: units.cpp.

===============================================================================================================================================

Задача 0.3. Единицы (часть 2)
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 1 с
        Ограничение по памяти: 256 МБ

Дано число N. Необходимо определить, сколько есть бинарных строк длины N, в которых ровно K единиц.

Формат входных данных
Первая строка входных данных содержит два целых неотрицательных числа N и K (0 ≤ K ≤ N ≤ 10^6).

Формат выходных данных
Выведите одно число - ответ на задачу. Так как ответ может быть очень большим, необходимо его вывести по модулю $10^9 + 7$.

Примеры
стандартный ввод  |  стандартный вывод
_______________________________________
3 2		  |3
---------------------------------------
4 0		  |1
---------------------------------------
5 4		  |5
---------------------------------------
6 4		  |15
---------------------------------------
7 2		  |21
---------------------------------------
8 0		  |1

Решение к задаче: units2.cpp.

===============================================================================================================================================

Задача 0.4. Порядок перемножения матриц
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

Дана последовательность из s матриц A1, A2, …, As. Требуется определить, в каком порядке их следует перемножать, чтобы число атомарных операций 
умножения было минимальным. Матрицы предполагаются совместимыми по отношению к матричному умножению (т. е. число столбцов матрицы Ai − 1 
совпадает с числом строк матрицы Ai).

Будем считать, что произведение матриц — операция, которая принимает на вход две матрицы размера k * m и m * n и возвращает матрицу размера 
k * n, затратив на это kmn атомарных операций умножения. (Базовый тип позволяет хранить любой элемент итоговой и любой возможной промежуточной 
матрицы, поэтому умножение двух элементов требует одной атомарной операции.)

Так как перемножение матриц ассоциативно, итоговая матрица не зависит от порядка выполнения операций умножения. Другими словами, нет разницы, в 
каком порядке расставляются скобки между множителями, результат будет один и тот же.

Формат входных данных
В первой строке задано число s матриц (2 ≤ s ≤ 100). В последующих s строках заданы размеры матриц: строка i + 1 содержит через пробел число ni 
строк и число mi столбцов матрицы Ai (1 ≤ ni, mi ≤ 100). Гарантируется, что mi совпадает с ni + 1 для всех индексов i от 1 до s − 1.

Формат выходных данных
Выведите минимальное число атомарных операций умножения, необходимое для перемножения s матриц.

Примеры
input.txt	|	output.txt
___________________________________
3		|130
2 3		|
3 5		|
5 10		|
-----------------------------------
4		|3100
20 5		|
5 35		|
35 4		|
4 25		|

Замечание
В первом примере можно умножать двумя способами:
(A1(A2A3)): требуется 3 * 5 × 10 + 2 * 3 * 10 = 150 + 60 = 210 операций;
((A1A2)A3): требуется 2 * 3 × 5 + 2 * 5 * 10 = 30 + 100 = 130 операций.
Второй способ эффективнее.

Решение к задаче: matrix.cpp.

===============================================================================================================================================

Задача 0.5. LCS
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 2 с
        Ограничение по памяти: 64 МБ

Даны две последовательности A и B, каждая имеет длину n.
Найти наибольшее k, для которого существуют две последовательности индексов 0 ≤ i_1 < i_2 < ... < i_k < n и 0 ≤ j_1 < j_2 < ... < j_k < n, что 
A_{i_1} = B_{j_1}, A_{i_2} = B_{j_2}, …, A_{i_k} = B_{j_k}.Также нужно найти и сами последовательности индексов.

Формат входных данных
В первой строке записано число n (1 ≤ n ≤ 1000), длина последовательностей A и B.
Во второй строке содержится n целых чисел a_i (1 ≤ a_i ≤ 1000) — элементы последовательности A.
В третьей строке содержатся n целых чисел b_j (1 ≤ b_j ≤ 1000) — элементы последовательности B.

Формат выходных данных
В первой строке выведите число k. 
Во второй строке выведите индексы i_1, i_2, ..., i_k.
В третьей строке выведите индексы j_1, j_2, ..., j_k.
Если подходящий последовательностей индексов несколько, выведите любые из них.

Примеры
стандартный ввод	|  	стандартный вывод
__________________________________________________
2			|2
1 2			|0 1
1 2			|0 1
--------------------------------------------------
5			|3
1 2 3 4 5		|0 1 3
1 3 2 4 4		|0 2 4
--------------------------------------------------
6			|4
1 2 3 3 4 6		|0 2 3 4
1 6 3 3 2 4		|0 2 3 5

Решение к задаче: LCS.cpp.

===============================================================================================================================================

Задача 0.6. Палиндром
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: нет

Вводится непустая строка S, которая имеет длину не более 7000 символов и состоит только из строчных латинских букв. Необходимо удалить из 
строки минимальное число символов так, чтобы получился палиндром (строка символов, которая читается слева направо и справа налево одинаково).

Формат входных данных
В первой строке записана исходная строка S.

Формат выходных данных
Выведите в первой строке длину получившегося палиндрома, а во второй строке сам палиндром (если палиндромов несколько, то выведите только один из них).

Пример
input.txt	|	output.txt
___________________________________
asddfsa		|	6
		|	asddsa

Решение к задаче: palindrom.cpp.

===============================================================================================================================================

Задача 0.7. Строго возрастающая без разрывов подпоследовательность
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: от 1 с до 5 с
	Ограничение по памяти: нет

Необходимо из заданной числовой последовательности A, состоящей из n элементов, вычеркнуть минимальное число элементов так, чтобы оставшиеся 
элементы образовали строго возрастающую подпоследовательность элементов. Построенный алгоритм должен иметь трудоёмкость O(n log n).

Замечание
Возрастание без разрывов подразумевает, что каждый следующий элемент подпоследовательности строго больше предыдущего.

Формат входных данных
Первая строка входного файла содержит число n (1 ≤ n ≤  700 000). Следующая строка содержит n элементов последовательности A, которые разделены 
пробелами (элементы последовательности — целые числа, не превосходящие по модулю 1 000 000 000).

Формат выходных данных
Выведите одно число — длину строго возрастающей подпоследовательности элементов.

Пример
input.txt	|	output.txt
___________________________________
6		|5
1 2 3 4 7 6	|

Решение к задаче: LIS.cpp.

===============================================================================================================================================

Задача 23. Канадские авиалинии
	Имя входного файла: in.txt
	Имя выходного файла: out.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: нет

Вы победили в соревновании, организованном Канадскими авиалиниями. Приз — бесплатное путешествие по Канаде. Путешествие начинается 
с самого западного города, в который летают самолеты, проходит с запада на восток, пока не достигнет самого восточного города, в который 
летают самолеты. Затем путешествие продолжается обратно с востока на запад, пока не достигнет начального города. Ни один из городов нельзя 
посещать более одного раза, за исключением начального города, который надо посетить ровно дважды (в начале и конце путешествия). Вам также 
нельзя пользоваться авиалиниями других компаний или другими способами передвижения. Необходимо для данного списка городов и списка прямых 
рейсов между парами городов найти маршрут, включающий максимальное число городов и удовлетворяющий выше названным условиям.

Формат входных данных
В первой строке записано число n городов (2 ≤ n ≤ 500) и число m прямых рейсов (положительное целое число). В каждой из следующих 
n строк — название города, в который летают самолеты. Названия упорядочены с запада на восток, т. е. i-й по порядку город находится 
восточнее j-го тогда и только тогда, когда i > j (не существует городов на одном меридиане). Название каждого города — строка, состоящая 
не более чем из 15 цифр и/или латинских букв, например: AGR34 или BELA. В каждой из следующих m строк — названия двух различных городов 
из списка городов, разделённые пробелом. Если пара (ГОРОД1, ГОРОД2) содержится в строке, то это означает, что есть прямой рейс из ГОРОД1 
в ГОРОД2, а также прямой рейс из ГОРОД2 в ГОРОД1.

Формат выходных данных
Если маршрута не существует, то выведите строку No solution. Если же маршрут существует, то выведите число различных городов, посещаемых 
в маршруте.

Примеры
in.txt  |  out.txt
___________________
2 1		|2
C1		|
C2		|
C1 C2	|
___________________
5 3		|No solution
g1		|
g2		|
g3		|
g4		|
g5		|
g1 g2	|
g2 g3	|
g3 g5	|

Решенине к задаче: CanadianAirlines.cpp.

===============================================================================================================================================

Задача 0.1. Построить дерево
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

По набору ключей постройте бинарное поисковое дерево и выполните его прямой левый обход.

Формат входных данных
Входной файл содержит последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке.
В поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется.

Формат выходных данных
Выходной файл должен содержать последовательность ключей вершин, полученную прямым левым обходом дерева.

Примеры
input.txt  |  output.txt
_________________________
2		   |2
3		   |3
_________________________
5		   |5
2		   |2
4		   |1
1		   |4
8		   |8
7		   |7
_________________________
0		   |0
100		   |-100
-100	   |100

Решение к задаче: binary_tree01.cpp.

===============================================================================================================================================

Задача 0.2. Удалить из дерева
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

По набору ключей постройте бинарное поисковое дерево. Удалите из него ключ (правым удалением), если он есть в дереве. Выполните прямой левый 
обход полученного дерева.

Формат входных данных
В первой строке записано целое число — ключ, который нужно удалить из дерева.
Вторая строка пустая.

Последующие строки содержат последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке. 
Дерево содержит хотя бы две вершины.

Напомним, что в поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, 
он игнорируется.

Формат выходных данных
Выведите последовательность ключей вершин, полученную прямым левым обходом дерева.

Примеры
input.txt  |  output.txt
_________________________
3		   |2
		   |1
2		   |
3		   |
1		   |
_________________________
2		   |4
		   |3
4		   |1
2		   |5
1		   |
3		   |
5		   |

Решение к задаче: binary_tree02.cpp.

===============================================================================================================================================

Задача 0.3. Является ли бинарное дерево поисковым?
        Имя входного файла: bst.in
        Имя выходного файла: bst.out
        Ограничение по времени: 1 с
        Ограничение по памяти: 64 МБ

Задано бинарное дерево. Необходимо проверить, является ли оно поисковым.
Будем предполагать, что в бинарном поисковом дереве могут быть вершины с одинаковыми ключами. Тогда, для того, чтобы дерево было поисковым, 
должно выполняться следующее требование: для каждой вершины x все ключи в левом поддереве вершины x меньше ключа вершины x, а все ключи 
в правом поддереве больше либо равны ключу вершины x.

Формат входных данных
Первая строка входного файла содержит единственное целое число n (1 ≤ n ≤ 8*10^5) – количество вершин в дереве.
Следующая строка содержит одно целое число m (-2^31 ≤ m ≤ 2^31 - 1) – значение в корневой вершине дерева.
В каждой из последующих n - 1 строк через пробелы перечисляются три параметра m, p и c, которые задают какую-либо вершину дерева.
m – целое число (-2^31 ≤ m ≤ 2^31 - 1), значение, записанное в вершине.
p – целое число (1 ≤ p ≤ n - 1), номер строки входного файла, в которой был задан родитель текущей вершины (нумерация строк с нуля). 
Гарантируется, что p меньше, чем номер текущей строки.
c может принимать одно из двух значений `L' или `R'. Значение `L' указывает на то, что текущая вершина присоединена к родительской слева, 
`R' – справа.
Гарантируется, что совокупность всех строк задает корректное бинарное дерево.

Формат выходных данных
В единственной строке выведите `YES', если заданное дерево является бинарным деревом поиска, и `NO' в противном случае.

Пример
bst.in	|  bst.out
___________________
7		|NO
1		|
2 1 L	|
4 2 L	|
3 1 R	|
5 2 R	|
6 4 L	|
7 4 R	|

Решение к задаче: binary_tree03.cpp.

===============================================================================================================================================

Задача 0.2. Бинарная куча?
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

Напомним, что для компактного хранения в памяти компьютера полного бинарного дерева на n вершинах можно использовать одномерный массив длины n. 
Ключи вершин являются значениями элементов массива, индексация начинается с единицы, при этом у элемента с индексом i сыновьями являются 
элементы с индексами 2i и 2i + 1 (если такие элементы существуют).

Бинарная куча — полное бинарное дерево, для которого выполняется основное свойство структуры данных «куча»: элементы организованы таким 
образом, что приоритет любой вершины не ниже приоритета каждого из её сыновей.

Будем предполагать, что среди элементов тот элемент имеет наибольший приоритет, у которого ключевое значение меньше (Min-Heap).

Задан массив из n чисел. Необходимо проверить, может ли он представлять бинарную кучу.

Запрещается использовать специальные методы проверки из стандартных библиотек (std::is_heap в C++ и пр.).

Формат входных данных
В первой строке записано число n элементов в массиве (1 ≤ n ≤ 100 000). Во второй строке через пробел записаны n целых чисел, не превосходящих 
по модулю 10^9, — элементы массива.

Формат выходных данных
Выведите Yes, если существует бинарная куча, которая в памяти представляется заданным массивом, или No иначе.

Пример
input.txt				     |		output.txt
_______________________________________________
10							 |Yes
9 17 16 25 21 20 60 25 40 33 |

Решение к задаче: 0.2.isBinaryHeap.cpp.

===============================================================================================================================================

Задача 0.4. Кодирование Хаффмана (сложная версия)
        Имя входного файла: huffman.in
        Имя выходного файла: huffman.out
        Ограничение по времени: 0,5 с
        Ограничение по памяти: 256 МБ
        
Кодирование Хаффмана (D. A. Huffman) относится к префиксному кодированию, позволяющему минимизировать длину текста за счёт того, 
что различные символы кодируются различным числом битов.
Напомним процесс построения кода. Вначале строится дерево кода Хаффмана. Пусть исходный алфавит состоит из n символов, i-й из которых 
встречается p_i раз во входном тексте. Изначально все символы считаются активными вершинами будущего дерева, i-я вершина помечена 
значением p_i. На каждом шаге мы берём две активных вершины с наименьшими метками, создаём новую вершину, помечая её суммой меток этих вершин, 
и делаем её их родителем. Новая вершина становится активной, а двое её сыновей из списка активных вершин удаляются. Процесс многократно 
повторяется, пока не останется только одна активная вершина, которая полагается корнем дерева.
Заметим, что символы алфавита представлены листьями этого дерева. Для каждого листа (символа) длина его кода Хаффмана равна длине пути от корня 
дерева до него. Сам код строится следующим образом: для каждой внутренней вершины дерева рассмотрим две дуги, идущие от неё к сыновьям. 
Одной из дуг присвоим метку 0, другой — 1. Код каждого символа — последовательность из нулей и единиц на пути от корня к листу.
Задача состоит в том, чтобы вычислить длину текста после его кодирования методом Хаффмана. Сам текст не дан, известно лишь, сколько раз 
каждый символ встречается в тексте. Этого достаточно для решения задачи, поскольку длина кода зависит только от частоты появления символов. 
Разработайте алгоритм, работающий за n, где n - количество частот появления символов. 

Формат входных данных
Первая строка содержит целое число n (2 ≤ n ≤ 2500000).Вторая строка содержит n чисел p_i — частоты появления символов в тексте 
(1 ≤ p_i ≤ 10^9, p_i ≤ p_{i+1} для каждого i от 1 до n-1).

Формат выходных данных
Выведите единственное число — длину (в битах) закодированного текста.

Пример
huffman.in		|	   huffman.out
___________________________________
6				|42
1 1 2 2 5 8		|

Решение к задаче: sizeOfHaffmanText.cpp.

===============================================================================================================================================

Задача 0.5. Строительство дорог
    
    
        Имя входного файла: input.txt
        Имя выходного файла: output.txt
        Ограничение по времени: 1 с
        Ограничение по памяти: 256 МБ
        
Берляндия состоит из n городов. Изначально все города изолированы, то есть между городами нету дорог.
По очереди будут добавляться дороги между парами городов. Необходимо после каждой добавленной дороги узнать, какое количество компонент 
связности из городов получилось.

Формат входных данных
Первая строка входного файла содержит два целых числа n и q (1 ≤ n, q ≤ 500000) — количество городов и запросов соответственно.
Каждая из следующих q строк содержит два целых числа u, v — между какой парой городов будет построена дорога. В данной задаче между любой 
парой городов строится не более одной дороги, а для любого запроса справедливо u != v.

Формат выходных данных
На каждый запрос второго типа необходимо вывести одно число — количество компонент связности в графе из городов.

Пример
input.txt	|   output.txt
_________________________
5 5			|4
1 2			|3
3 4			|2
1 3			|1
3 5			|1
1 5			|

Решение к задаче: roadConstruction.cpp.

===============================================================================================================================================

Задача 0.6. Разрушение дорог (простая версия)
        Имя входного файла: input.txt
        Имя выходного файла: output.txt
        Ограничение по времени: 1 с
        Ограничение по памяти: 256 МБ
        
В Берляндии n городов, связанных m дорогами. Гарантируется, что изначально граф из городов связный, т.е. существует путь между любой парой 
вершин.
В Берляндии происходит q землетрясений, в ходе каждого из них разрушается ровно одна дорога. Необходимо после каждого землетрясения узнать, 
является ли полученный граф из городов связным. После очередного землетрясений дорога не перестраивается, то есть разрушается навсегда.

Формат входных данных
Первая строка входного файла содержит три числа n, m, q (1 ≤ n, m, q ≤ 100000, 2 ≤ n) - количество городов, дорог и землетрясений в Берляндии 
соответственно.
Следующие m строк содержат по два натуральных числа u и v (1 ≤ u, v ≤ n) - номера городов, связанных дорогой. Гарантируется, что u != v и между
каждой парой городов существует не больше одной дороги.
Следующие q строк содержат по одному числу x_i (1 ≤ x_i ≤ m) - номер дороги, которая пострадает во время i-ого землетрясения. 
Гарантируется, что два различных землетрясения не разрушают одну и ту же дорогу.

Формат выходных данных
Выведите строку длины q из нулей и единиц. i-ый символ равен 1, если после i-ого землетрясения граф оказался связным, в противном случае 
выведите 0.

Пример
input.txt   |   output.txt
_________________________
4 6 6		|110000
1 2			|
2 3			|
3 4			|
4 1			|
3 1			|
4 2			|
1			|
6			|
2			|
5			|
4			|
3			|

Решение к задаче: roadDestruction.cpp.

===============================================================================================================================================

Задача 0.7. Разрушение дорог (сложная версия)
        Имя входного файла: input.txt
        Имя выходного файла: output.txt
        Ограничение по времени: 1,25 с
        Ограничение по памяти: 256 МБ
        
В Берляндии n городов, связанных m дорогами. Гарантируется, что изначально граф из городов связный, т.е. существует путь между любой парой 
вершин.
В Берляндии происходит q землетрясений, в ходе каждого из них разрушается ровно одна дорога. Необходимо после каждого землетрясения узнать, 
является ли полученный граф из городов связным. После очередного землетрясений дорога не перестраивается, то есть разрушается навсегда.

Формат входных данных
Первая строка входного файла содержит три числа n, m, q (1 ≤ n, m, q ≤ 750000, 2 ≤ n) - количество городов, дорог и землетрясений в Берляндии 
соответственно.
Следующие m строк содержат по два натуральных числа u и v (1 ≤ u, v ≤ n) - номера городов, связанных дорогой. Гарантируется, что u != v и между
каждой парой городов существует не больше одной дороги.
Следующие q строк содержат по одному числу x_i (1 ≤ x_i ≤ m) - номер дороги, которая пострадает во время i-ого землетрясения. 
Гарантируется, что два различных землетрясения не разрушают одну и ту же дорогу.

Формат выходных данных
Выведите строку длины q из нулей и единиц. i-ый символ равен 1, если после i-ого землетрясения граф оказался связным, в противном случае 
выведите 0.

Пример
input.txt   |   output.txt
_________________________
4 6 6		|110000
1 2			|
2 3			|
3 4			|
4 1			|
3 1			|
4 2			|
1			|
6			|
2			|
5			|
4			|
3			|

Решение к задаче: roadDestruction.cpp.

===============================================================================================================================================

Задача 0.8. Задача о сумме
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 2 с
        Ограничение по памяти: 256 МБ

Рассмотрим следующую модельную задачу. Изначально дана последовательность чисел A длины n (индексация с нуля):
a_0, a_1, a_2, ... a_{n-1}.

Поступают запросы двух типов.
Запрос модификации. Задан индекс i и число x. Нужно прибавить к i-му элементу число x.
Запрос суммы. Задана пара индексов l и r. Нужно вычислить сумму элементов на полуинтервале [l, r), т. е. a_l + a_{l+1} + ... + a_{r - 1}, 
и вернуть результат.

Формат входных данных
В первой строке записано целое число n — количество элементов массива (1 ≤ n ≤ 300000).
Во второй строке записаны n целых чисел a_i (-10^9 ≤ a_i ≤ 10^9).
В третьей строке записано целое число q — количество запросов (1 ≤ q ≤ 300000).
Каждая из следующих q строк задаёт один запрос. Если это запрос модификации, то в строке записано слово Add, затем индекс i (0 ≤ i < n) 
и число x (-10^9 ≤ x ≤ 10^9). Если это запрос суммы, то он задаётся словом FindSum и двумя индексами l и r (0 ≤ l < r ≤ n) — границами 
полуинтервала.

Формат выходных данных
Для каждого запроса второго типа выведите в отдельной строке сумму элементов на соответствующем полуинтервале.

Пример
стандартный ввод|стандартный вывод
___________________________________
5               |30
10 30 40 -10 20 |70
7               |60
FindSum 1 2     |10
FindSum 1 3     |0
FindSum 1 4     |80
FindSum 3 5     |
Add 4 -10       |
FindSum 3 5     |
FindSum 0 5     |

Решение к задаче: RSQonIntervalTree.cpp.

===============================================================================================================================================
