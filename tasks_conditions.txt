Задача 0.1. Бинарный поиск    
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 3 с
        Ограничение по памяти: 256 МБ

Реализуйте бинарный поиск на массиве чисел, отсортированном в неубывающем порядке. 
Запрещается использование готовых функций бинарного поиска из стандартных библиотек. 

Формат входных данных
В первой строке записано целое число n — количество чисел в массиве (0 ≤ n ≤ 3 * 10^5).
Во второй строке через пробел записаны n чисел массива. Все числа целые и принадлежат промежутку от -2^31 до 2^31 - 1 включительно. Числа в
массиве упорядочены по неубыванию.
В третьей строке записано целое число k — количество запросов (0 ≤ k ≤ 3 * 10^5).
В четвёртой строке через пробел записаны k целых чисел-запросов из промежутка от -2^31 до 2^31 - 1 включительно.

Формат выходных данных
Для каждого числа-запроса x в отдельной строке выведите через пробел числа b, l и r, где b равно 1, если x присутствует в массиве, или 0 в 
противном случае; l — индекс первого элемента, большего либо равного x; r — индекс первого элемента, большего x. Элементы массива нумеруются 
индексами от 0 до n-1.Если подходящих элементов в массиве нет, договоримся, что возвращаемый индекс будет равен n.

Пример
стандартный ввод  |  стандартный вывод	
_______________________________________
4		  |0 0 0
1 2 2 3		  |1 0 1
5		  |1 1 3
0 1 2 3 4	  |1 3 4
		  |0 4 4

Решение к задаче: Bin_search.cpp.

===============================================================================================================================================

Задача 0.1. Путь лягушки 
	Имя входного файла: стандартный ввод 
	Имя выходного файла: стандартный вывод 
	Ограничение по времени: 1 с 
	Ограничение по памяти: 256 МБ

В одном очень длинном и узком пруду по кувшинкам прыгает лягушка. Кувшинки в пруду расположены в один ряд. Лягушка начинает прыгать с первой 
кувшинки ряда и хочет закончить на последней. Но в силу вредности характера лягушка согласна прыгать только вперед через одну или через две 
кувшинки. Например, с кувшинки номер 1 она может прыгнуть лишь на кувшинки номер 3 и номер 4. 
На некоторых кувшинках сидят комарики. А именно, на i-ой кувшинке сидят a_i комаров. Когда лягушка приземляется на кувшинку, она съедает всех 
комариков, сидящих на ней. Лягушка хочет спланировать свой маршрут так, чтобы съесть как можно больше комаров. Помогите ей: скажите, какие 
кувшинки она должна посетить на своем пути.

Формат входных данных 
Первая строка входа содержит n — число кувшинок в пруду (1 ≤ n ≤ 100 000). Вторая строка содержит n чисел, разделенных одиночными пробелами. 
i-ое число сообщает, сколько комаров сидит на i-ой кувшинке (1 ≤ i ≤ n). Все числа целые, неотрицательные и не превосходят 1000.

Формат выходных данных 
В первой строке выведите одно число — максимальное число комаров, которые может съесть лягушка. Во второй строке выведите последовательность 
чисел — номера тех кувшинок, на которых должна побывать лягушка, в возрастающем порядке. Если решений несколько, выведите любое. Если лягушка 
не может добраться до последней кувшинки, то выведите одно число -1.

Пример 
стандартный ввод  |  стандартный вывод 
_______________________________________
6 		  |5
1 100 3 4 1000 0  |1 4 6
---------------------------------------
2		  |-1
8 9		  |

Решение к задаче: FrogWay.cpp.

===============================================================================================================================================

Задача 0.2. Единицы (часть 1)
	Имя входного файла: стандартный ввод
	Имя выходного файла: стандартный вывод
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

Дано число N. Необходимо определить, сколько есть бинарных строк длины N, в которых ровно K единиц.

Формат входных данных
Первая строка входных данных содержит два целых неотрицательных числа N и K (0 ≤ K ≤ N ≤ 1000).

Формат выходных данных
Выведите одно число — ответ на задачу. Так как ответ может быть очень большим, необходимо его вывести по модулю 10^9 + 7.

Примеры
стандартный ввод  |  стандартный вывод
_______________________________________
3 2               |3
---------------------------------------
4 0		  |1
---------------------------------------
5 4		  |5
---------------------------------------
6 4  		  |15
---------------------------------------
7 2		  |21
---------------------------------------
8 0		  |1

Решение к задаче: units.cpp.

===============================================================================================================================================

Задача 0.3. Единицы (часть 2)
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 1 с
        Ограничение по памяти: 256 МБ

Дано число N. Необходимо определить, сколько есть бинарных строк длины N, в которых ровно K единиц.

Формат входных данных
Первая строка входных данных содержит два целых неотрицательных числа N и K (0 ≤ K ≤ N ≤ 10^6).

Формат выходных данных
Выведите одно число - ответ на задачу. Так как ответ может быть очень большим, необходимо его вывести по модулю $10^9 + 7$.

Примеры
стандартный ввод  |  стандартный вывод
_______________________________________
3 2		  |3
---------------------------------------
4 0		  |1
---------------------------------------
5 4		  |5
---------------------------------------
6 4		  |15
---------------------------------------
7 2		  |21
---------------------------------------
8 0		  |1

Решение к задаче: units2.cpp.

===============================================================================================================================================

Задача 0.4. Порядок перемножения матриц
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

Дана последовательность из s матриц A1, A2, …, As. Требуется определить, в каком порядке их следует перемножать, чтобы число атомарных операций 
умножения было минимальным. Матрицы предполагаются совместимыми по отношению к матричному умножению (т. е. число столбцов матрицы Ai − 1 
совпадает с числом строк матрицы Ai).

Будем считать, что произведение матриц — операция, которая принимает на вход две матрицы размера k * m и m * n и возвращает матрицу размера 
k * n, затратив на это kmn атомарных операций умножения. (Базовый тип позволяет хранить любой элемент итоговой и любой возможной промежуточной 
матрицы, поэтому умножение двух элементов требует одной атомарной операции.)

Так как перемножение матриц ассоциативно, итоговая матрица не зависит от порядка выполнения операций умножения. Другими словами, нет разницы, в 
каком порядке расставляются скобки между множителями, результат будет один и тот же.

Формат входных данных
В первой строке задано число s матриц (2 ≤ s ≤ 100). В последующих s строках заданы размеры матриц: строка i + 1 содержит через пробел число ni 
строк и число mi столбцов матрицы Ai (1 ≤ ni, mi ≤ 100). Гарантируется, что mi совпадает с ni + 1 для всех индексов i от 1 до s − 1.

Формат выходных данных
Выведите минимальное число атомарных операций умножения, необходимое для перемножения s матриц.

Примеры
input.txt	|	output.txt
___________________________________
3		|130
2 3		|
3 5		|
5 10		|
-----------------------------------
4		|3100
20 5		|
5 35		|
35 4		|
4 25		|

Замечание
В первом примере можно умножать двумя способами:
(A1(A2A3)): требуется 3 * 5 × 10 + 2 * 3 * 10 = 150 + 60 = 210 операций;
((A1A2)A3): требуется 2 * 3 × 5 + 2 * 5 * 10 = 30 + 100 = 130 операций.
Второй способ эффективнее.

Решение к задаче: matrix.cpp.

===============================================================================================================================================

Задача 0.5. LCS
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 2 с
        Ограничение по памяти: 64 МБ

Даны две последовательности A и B, каждая имеет длину n.
Найти наибольшее k, для которого существуют две последовательности индексов 0 ≤ i_1 < i_2 < ... < i_k < n и 0 ≤ j_1 < j_2 < ... < j_k < n, что 
A_{i_1} = B_{j_1}, A_{i_2} = B_{j_2}, …, A_{i_k} = B_{j_k}.Также нужно найти и сами последовательности индексов.

Формат входных данных
В первой строке записано число n (1 ≤ n ≤ 1000), длина последовательностей A и B.
Во второй строке содержится n целых чисел a_i (1 ≤ a_i ≤ 1000) — элементы последовательности A.
В третьей строке содержатся n целых чисел b_j (1 ≤ b_j ≤ 1000) — элементы последовательности B.

Формат выходных данных
В первой строке выведите число k. 
Во второй строке выведите индексы i_1, i_2, ..., i_k.
В третьей строке выведите индексы j_1, j_2, ..., j_k.
Если подходящий последовательностей индексов несколько, выведите любые из них.

Примеры
стандартный ввод	|  	стандартный вывод
__________________________________________________
2			|2
1 2			|0 1
1 2			|0 1
--------------------------------------------------
5			|3
1 2 3 4 5		|0 1 3
1 3 2 4 4		|0 2 4
--------------------------------------------------
6			|4
1 2 3 3 4 6		|0 2 3 4
1 6 3 3 2 4		|0 2 3 5

Решение к задаче: LCS.cpp.

===============================================================================================================================================

Задача 0.6. Палиндром
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: нет

Вводится непустая строка S, которая имеет длину не более 7000 символов и состоит только из строчных латинских букв. Необходимо удалить из 
строки минимальное число символов так, чтобы получился палиндром (строка символов, которая читается слева направо и справа налево одинаково).

Формат входных данных
В первой строке записана исходная строка S.

Формат выходных данных
Выведите в первой строке длину получившегося палиндрома, а во второй строке сам палиндром (если палиндромов несколько, то выведите только один из них).

Пример
input.txt	|	output.txt
___________________________________
asddfsa		|	6
		|	asddsa

Решение к задаче: palindrom.cpp.

===============================================================================================================================================

Задача 0.7. Строго возрастающая без разрывов подпоследовательность
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: от 1 с до 5 с
	Ограничение по памяти: нет

Необходимо из заданной числовой последовательности A, состоящей из n элементов, вычеркнуть минимальное число элементов так, чтобы оставшиеся 
элементы образовали строго возрастающую подпоследовательность элементов. Построенный алгоритм должен иметь трудоёмкость O(n log n).

Замечание
Возрастание без разрывов подразумевает, что каждый следующий элемент подпоследовательности строго больше предыдущего.

Формат входных данных
Первая строка входного файла содержит число n (1 ≤ n ≤  700 000). Следующая строка содержит n элементов последовательности A, которые разделены 
пробелами (элементы последовательности — целые числа, не превосходящие по модулю 1 000 000 000).

Формат выходных данных
Выведите одно число — длину строго возрастающей подпоследовательности элементов.

Пример
input.txt	|	output.txt
___________________________________
6		|5
1 2 3 4 7 6	|

Решение к задаче: LIS.cpp.

===============================================================================================================================================

Задача 23. Канадские авиалинии
	Имя входного файла: in.txt
	Имя выходного файла: out.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: нет

Вы победили в соревновании, организованном Канадскими авиалиниями. Приз — бесплатное путешествие по Канаде. Путешествие начинается 
с самого западного города, в который летают самолеты, проходит с запада на восток, пока не достигнет самого восточного города, в который 
летают самолеты. Затем путешествие продолжается обратно с востока на запад, пока не достигнет начального города. Ни один из городов нельзя 
посещать более одного раза, за исключением начального города, который надо посетить ровно дважды (в начале и конце путешествия). Вам также 
нельзя пользоваться авиалиниями других компаний или другими способами передвижения. Необходимо для данного списка городов и списка прямых 
рейсов между парами городов найти маршрут, включающий максимальное число городов и удовлетворяющий выше названным условиям.

Формат входных данных
В первой строке записано число n городов (2 ≤ n ≤ 500) и число m прямых рейсов (положительное целое число). В каждой из следующих 
n строк — название города, в который летают самолеты. Названия упорядочены с запада на восток, т. е. i-й по порядку город находится 
восточнее j-го тогда и только тогда, когда i > j (не существует городов на одном меридиане). Название каждого города — строка, состоящая 
не более чем из 15 цифр и/или латинских букв, например: AGR34 или BELA. В каждой из следующих m строк — названия двух различных городов 
из списка городов, разделённые пробелом. Если пара (ГОРОД1, ГОРОД2) содержится в строке, то это означает, что есть прямой рейс из ГОРОД1 
в ГОРОД2, а также прямой рейс из ГОРОД2 в ГОРОД1.

Формат выходных данных
Если маршрута не существует, то выведите строку No solution. Если же маршрут существует, то выведите число различных городов, посещаемых 
в маршруте.

Примеры
in.txt  |  out.txt
___________________
2 1		|2
C1		|
C2		|
C1 C2	|
___________________
5 3		|No solution
g1		|
g2		|
g3		|
g4		|
g5		|
g1 g2	|
g2 g3	|
g3 g5	|

Решенине к задаче: CanadianAirlines.cpp.

===============================================================================================================================================

Задача 0.1. Построить дерево
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

По набору ключей постройте бинарное поисковое дерево и выполните его прямой левый обход.

Формат входных данных
Входной файл содержит последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке.
В поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется.

Формат выходных данных
Выходной файл должен содержать последовательность ключей вершин, полученную прямым левым обходом дерева.

Примеры
input.txt  |  output.txt
_________________________
2		   |2
3		   |3
_________________________
5		   |5
2		   |2
4		   |1
1		   |4
8		   |8
7		   |7
_________________________
0		   |0
100		   |-100
-100	   |100

Решение к задаче: binary_tree01.cpp.

===============================================================================================================================================

Задача 0.2. Удалить из дерева
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

По набору ключей постройте бинарное поисковое дерево. Удалите из него ключ (правым удалением), если он есть в дереве. Выполните прямой левый 
обход полученного дерева.

Формат входных данных
В первой строке записано целое число — ключ, который нужно удалить из дерева.
Вторая строка пустая.

Последующие строки содержат последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке. 
Дерево содержит хотя бы две вершины.

Напомним, что в поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, 
он игнорируется.

Формат выходных данных
Выведите последовательность ключей вершин, полученную прямым левым обходом дерева.

Примеры
input.txt  |  output.txt
_________________________
3		   |2
		   |1
2		   |
3		   |
1		   |
_________________________
2		   |4
		   |3
4		   |1
2		   |5
1		   |
3		   |
5		   |

Решение к задаче: binary_tree02.cpp.

===============================================================================================================================================

Задача 0.3. Является ли бинарное дерево поисковым?
        Имя входного файла: bst.in
        Имя выходного файла: bst.out
        Ограничение по времени: 1 с
        Ограничение по памяти: 64 МБ

Задано бинарное дерево. Необходимо проверить, является ли оно поисковым.
Будем предполагать, что в бинарном поисковом дереве могут быть вершины с одинаковыми ключами. Тогда, для того, чтобы дерево было поисковым, 
должно выполняться следующее требование: для каждой вершины x все ключи в левом поддереве вершины x меньше ключа вершины x, а все ключи 
в правом поддереве больше либо равны ключу вершины x.

Формат входных данных
Первая строка входного файла содержит единственное целое число n (1 ≤ n ≤ 8*10^5) – количество вершин в дереве.
Следующая строка содержит одно целое число m (-2^31 ≤ m ≤ 2^31 - 1) – значение в корневой вершине дерева.
В каждой из последующих n - 1 строк через пробелы перечисляются три параметра m, p и c, которые задают какую-либо вершину дерева.
m – целое число (-2^31 ≤ m ≤ 2^31 - 1), значение, записанное в вершине.
p – целое число (1 ≤ p ≤ n - 1), номер строки входного файла, в которой был задан родитель текущей вершины (нумерация строк с нуля). 
Гарантируется, что p меньше, чем номер текущей строки.
c может принимать одно из двух значений `L' или `R'. Значение `L' указывает на то, что текущая вершина присоединена к родительской слева, 
`R' – справа.
Гарантируется, что совокупность всех строк задает корректное бинарное дерево.

Формат выходных данных
В единственной строке выведите `YES', если заданное дерево является бинарным деревом поиска, и `NO' в противном случае.

Пример
bst.in	|  bst.out
___________________
7		|NO
1		|
2 1 L	|
4 2 L	|
3 1 R	|
5 2 R	|
6 4 L	|
7 4 R	|

Решение к задаче: binary_tree03.cpp.

===============================================================================================================================================

Задача 0.2. Бинарная куча?
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

Напомним, что для компактного хранения в памяти компьютера полного бинарного дерева на n вершинах можно использовать одномерный массив длины n. 
Ключи вершин являются значениями элементов массива, индексация начинается с единицы, при этом у элемента с индексом i сыновьями являются 
элементы с индексами 2i и 2i + 1 (если такие элементы существуют).

Бинарная куча — полное бинарное дерево, для которого выполняется основное свойство структуры данных «куча»: элементы организованы таким 
образом, что приоритет любой вершины не ниже приоритета каждого из её сыновей.

Будем предполагать, что среди элементов тот элемент имеет наибольший приоритет, у которого ключевое значение меньше (Min-Heap).

Задан массив из n чисел. Необходимо проверить, может ли он представлять бинарную кучу.

Запрещается использовать специальные методы проверки из стандартных библиотек (std::is_heap в C++ и пр.).

Формат входных данных
В первой строке записано число n элементов в массиве (1 ≤ n ≤ 100 000). Во второй строке через пробел записаны n целых чисел, не превосходящих 
по модулю 10^9, — элементы массива.

Формат выходных данных
Выведите Yes, если существует бинарная куча, которая в памяти представляется заданным массивом, или No иначе.

Пример
input.txt				     |		output.txt
_______________________________________________
10							 |Yes
9 17 16 25 21 20 60 25 40 33 |

Решение к задаче: 0.2.isBinaryHeap.cpp.

===============================================================================================================================================
