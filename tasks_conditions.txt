Задача 0.1. Бинарный поиск    
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 3 с
        Ограничение по памяти: 256 МБ

Реализуйте бинарный поиск на массиве чисел, отсортированном в неубывающем порядке. 
Запрещается использование готовых функций бинарного поиска из стандартных библиотек. 

Формат входных данных
В первой строке записано целое число n — количество чисел в массиве (0 ≤ n ≤ 3 * 10^5).
Во второй строке через пробел записаны n чисел массива. Все числа целые и принадлежат промежутку от -2^31 до 2^31 - 1 включительно. Числа в
массиве упорядочены по неубыванию.
В третьей строке записано целое число k — количество запросов (0 ≤ k ≤ 3 * 10^5).
В четвёртой строке через пробел записаны k целых чисел-запросов из промежутка от -2^31 до 2^31 - 1 включительно.

Формат выходных данных
Для каждого числа-запроса x в отдельной строке выведите через пробел числа b, l и r, где b равно 1, если x присутствует в массиве, или 0 в 
противном случае; l — индекс первого элемента, большего либо равного x; r — индекс первого элемента, большего x. Элементы массива нумеруются 
индексами от 0 до n-1.Если подходящих элементов в массиве нет, договоримся, что возвращаемый индекс будет равен n.

Пример
стандартный ввод  |  стандартный вывод	
_______________________________________
4		  |0 0 0
1 2 2 3		  |1 0 1
5		  |1 1 3
0 1 2 3 4	  |1 3 4
		  |0 4 4

Решение к задаче: Bin_search.cpp.

===============================================================================================================================================

Задача 0.1. Путь лягушки 
	Имя входного файла: стандартный ввод 
	Имя выходного файла: стандартный вывод 
	Ограничение по времени: 1 с 
	Ограничение по памяти: 256 МБ

В одном очень длинном и узком пруду по кувшинкам прыгает лягушка. Кувшинки в пруду расположены в один ряд. Лягушка начинает прыгать с первой 
кувшинки ряда и хочет закончить на последней. Но в силу вредности характера лягушка согласна прыгать только вперед через одну или через две 
кувшинки. Например, с кувшинки номер 1 она может прыгнуть лишь на кувшинки номер 3 и номер 4. 
На некоторых кувшинках сидят комарики. А именно, на i-ой кувшинке сидят a_i комаров. Когда лягушка приземляется на кувшинку, она съедает всех 
комариков, сидящих на ней. Лягушка хочет спланировать свой маршрут так, чтобы съесть как можно больше комаров. Помогите ей: скажите, какие 
кувшинки она должна посетить на своем пути.

Формат входных данных 
Первая строка входа содержит n — число кувшинок в пруду (1 ≤ n ≤ 100 000). Вторая строка содержит n чисел, разделенных одиночными пробелами. 
i-ое число сообщает, сколько комаров сидит на i-ой кувшинке (1 ≤ i ≤ n). Все числа целые, неотрицательные и не превосходят 1000.

Формат выходных данных 
В первой строке выведите одно число — максимальное число комаров, которые может съесть лягушка. Во второй строке выведите последовательность 
чисел — номера тех кувшинок, на которых должна побывать лягушка, в возрастающем порядке. Если решений несколько, выведите любое. Если лягушка 
не может добраться до последней кувшинки, то выведите одно число -1.

Пример 
стандартный ввод  |  стандартный вывод 
_______________________________________
6 		  |5
1 100 3 4 1000 0  |1 4 6
---------------------------------------
2		  |-1
8 9		  |

Решение к задаче: FrogWay.cpp.

===============================================================================================================================================

Задача 0.2. Единицы (часть 1)
	Имя входного файла: стандартный ввод
	Имя выходного файла: стандартный вывод
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

Дано число N. Необходимо определить, сколько есть бинарных строк длины N, в которых ровно K единиц.

Формат входных данных
Первая строка входных данных содержит два целых неотрицательных числа N и K (0 ≤ K ≤ N ≤ 1000).

Формат выходных данных
Выведите одно число — ответ на задачу. Так как ответ может быть очень большим, необходимо его вывести по модулю 10^9 + 7.

Примеры
стандартный ввод  |  стандартный вывод
_______________________________________
3 2               |3
---------------------------------------
4 0		  |1
---------------------------------------
5 4		  |5
---------------------------------------
6 4  		  |15
---------------------------------------
7 2		  |21
---------------------------------------
8 0		  |1

Решение к задаче: units.cpp.

===============================================================================================================================================

Задача 0.3. Единицы (часть 2)
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 1 с
        Ограничение по памяти: 256 МБ

Дано число N. Необходимо определить, сколько есть бинарных строк длины N, в которых ровно K единиц.

Формат входных данных
Первая строка входных данных содержит два целых неотрицательных числа N и K (0 ≤ K ≤ N ≤ 10^6).

Формат выходных данных
Выведите одно число - ответ на задачу. Так как ответ может быть очень большим, необходимо его вывести по модулю $10^9 + 7$.

Примеры
стандартный ввод  |  стандартный вывод
_______________________________________
3 2		  |3
---------------------------------------
4 0		  |1
---------------------------------------
5 4		  |5
---------------------------------------
6 4		  |15
---------------------------------------
7 2		  |21
---------------------------------------
8 0		  |1

Решение к задаче: units2.cpp.

===============================================================================================================================================

Задача 0.4. Порядок перемножения матриц
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

Дана последовательность из s матриц A1, A2, …, As. Требуется определить, в каком порядке их следует перемножать, чтобы число атомарных операций 
умножения было минимальным. Матрицы предполагаются совместимыми по отношению к матричному умножению (т. е. число столбцов матрицы Ai − 1 
совпадает с числом строк матрицы Ai).

Будем считать, что произведение матриц — операция, которая принимает на вход две матрицы размера k * m и m * n и возвращает матрицу размера 
k * n, затратив на это kmn атомарных операций умножения. (Базовый тип позволяет хранить любой элемент итоговой и любой возможной промежуточной 
матрицы, поэтому умножение двух элементов требует одной атомарной операции.)

Так как перемножение матриц ассоциативно, итоговая матрица не зависит от порядка выполнения операций умножения. Другими словами, нет разницы, в 
каком порядке расставляются скобки между множителями, результат будет один и тот же.

Формат входных данных
В первой строке задано число s матриц (2 ≤ s ≤ 100). В последующих s строках заданы размеры матриц: строка i + 1 содержит через пробел число ni 
строк и число mi столбцов матрицы Ai (1 ≤ ni, mi ≤ 100). Гарантируется, что mi совпадает с ni + 1 для всех индексов i от 1 до s − 1.

Формат выходных данных
Выведите минимальное число атомарных операций умножения, необходимое для перемножения s матриц.

Примеры
input.txt	|	output.txt
___________________________________
3		|130
2 3		|
3 5		|
5 10		|
-----------------------------------
4		|3100
20 5		|
5 35		|
35 4		|
4 25		|

Замечание
В первом примере можно умножать двумя способами:
(A1(A2A3)): требуется 3 * 5 × 10 + 2 * 3 * 10 = 150 + 60 = 210 операций;
((A1A2)A3): требуется 2 * 3 × 5 + 2 * 5 * 10 = 30 + 100 = 130 операций.
Второй способ эффективнее.

Решение к задаче: matrix.cpp.

===============================================================================================================================================

Задача 0.5. LCS
        Имя входного файла: стандартный ввод
        Имя выходного файла: стандартный вывод
        Ограничение по времени: 2 с
        Ограничение по памяти: 64 МБ

Даны две последовательности A и B, каждая имеет длину n.
Найти наибольшее k, для которого существуют две последовательности индексов 0 ≤ i_1 < i_2 < ... < i_k < n и 0 ≤ j_1 < j_2 < ... < j_k < n, что 
A_{i_1} = B_{j_1}, A_{i_2} = B_{j_2}, …, A_{i_k} = B_{j_k}.Также нужно найти и сами последовательности индексов.

Формат входных данных
В первой строке записано число n (1 ≤ n ≤ 1000), длина последовательностей A и B.
Во второй строке содержится n целых чисел a_i (1 ≤ a_i ≤ 1000) — элементы последовательности A.
В третьей строке содержатся n целых чисел b_j (1 ≤ b_j ≤ 1000) — элементы последовательности B.

Формат выходных данных
В первой строке выведите число k. 
Во второй строке выведите индексы i_1, i_2, ..., i_k.
В третьей строке выведите индексы j_1, j_2, ..., j_k.
Если подходящий последовательностей индексов несколько, выведите любые из них.

Примеры
стандартный ввод	|  	стандартный вывод
__________________________________________________
2			|2
1 2			|0 1
1 2			|0 1
--------------------------------------------------
5			|3
1 2 3 4 5		|0 1 3
1 3 2 4 4		|0 2 4
--------------------------------------------------
6			|4
1 2 3 3 4 6		|0 2 3 4
1 6 3 3 2 4		|0 2 3 5

Решение к задаче: LCS.cpp.

===============================================================================================================================================

Задача 0.6. Палиндром
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: нет

Вводится непустая строка S, которая имеет длину не более 7000 символов и состоит только из строчных латинских букв. Необходимо удалить из 
строки минимальное число символов так, чтобы получился палиндром (строка символов, которая читается слева направо и справа налево одинаково).

Формат входных данных
В первой строке записана исходная строка S.

Формат выходных данных
Выведите в первой строке длину получившегося палиндрома, а во второй строке сам палиндром (если палиндромов несколько, то выведите только один из них).

Пример
input.txt	|	output.txt
___________________________________
asddfsa		|	6
		|	asddsa

Решение к задаче: palindrom.cpp.

===============================================================================================================================================

Задача 0.7. Строго возрастающая без разрывов подпоследовательность
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: от 1 с до 5 с
	Ограничение по памяти: нет

Необходимо из заданной числовой последовательности A, состоящей из n элементов, вычеркнуть минимальное число элементов так, чтобы оставшиеся 
элементы образовали строго возрастающую подпоследовательность элементов. Построенный алгоритм должен иметь трудоёмкость O(n log n).

Замечание
Возрастание без разрывов подразумевает, что каждый следующий элемент подпоследовательности строго больше предыдущего.

Формат входных данных
Первая строка входного файла содержит число n (1 ≤ n ≤  700 000). Следующая строка содержит n элементов последовательности A, которые разделены 
пробелами (элементы последовательности — целые числа, не превосходящие по модулю 1 000 000 000).

Формат выходных данных
Выведите одно число — длину строго возрастающей подпоследовательности элементов.

Пример
input.txt	|	output.txt
___________________________________
6		|5
1 2 3 4 7 6	|

Решение к задаче: LIS.cpp.

===============================================================================================================================================

Задача 0.1. Построить дерево
	Имя входного файла: input.txt
	Имя выходного файла: output.txt
	Ограничение по времени: 1 с
	Ограничение по памяти: 256 МБ

По набору ключей постройте бинарное поисковое дерево и выполните его прямой левый обход.

Формат входных данных
Входной файл содержит последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке.
В поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется.

Формат выходных данных
Выходной файл должен содержать последовательность ключей вершин, полученную прямым левым обходом дерева.

Примеры
input.txt  |  output.txt
_________________________
2
3
2
3
5
2
4
1
8
7
5
2
1
4
8
7
0
100
-100
0
-100
100